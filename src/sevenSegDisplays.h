/**
 * @file		: SevenSegDisplays.h
 * @brief	: Header file for SevenSegDisplays library classes
 *
 * @author	: Gabriel D. Goldman
 * @date		: Created on: Nov 16, 2023
 */
#ifndef _SEVENSEGDISPLAYS_STM32_H_
#define _SEVENSEGDISPLAYS_STM32_H_

#include "SevenSegDispHw.h"

#include <stdint.h>
#include <string>
#include <stdio.h>
#include <cstring>	//Eliminate by replacing the use of strcpy and strcat
//===========================>> Next lines included for developing purposes, corresponding headers must be provided for the production platform/s
#include "stm32f4xx_hal.h"
#include "stm32f4xx_hal_gpio.h"
//===========================>> Previous lines included for developing purposes, corresponding headers must be provided for the production platform/s

//===========================>> Next lines used to avoid CMSIS wrappers
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
//#include "queue.h"
//#include "semphr.h"
#include "event_groups.h"
//===========================>> Previous lines used to avoid CMSIS wrappers

const int MAX_DIGITS_PER_DISPLAY{8};
const int MAX_DISPLAYS_QTY{10};

//============================================================> Class declarations separator

/**
 * @brief Implements a seven segment display object
 *
 * @class SevenSegDisplays
 */
class SevenSegDisplays {
    static uint8_t _displaysCount;
    static uint16_t _dspSerialNum;
    static uint8_t _dspPtrArrLngth;
    static SevenSegDisplays** _instancesLstPtr;

    static TimerHandle_t _blinkTmrHndl;
    static TimerHandle_t _waitTmrHndl;

    static void tmrCbBlink(TimerHandle_t blinkTmrCbArg);
    static void tmrCbWait(TimerHandle_t waitTmrCbArg);
private:
    uint8_t _waitChar {0xBF};
    uint8_t _waitCount {0};
    bool _waiting {false};
    unsigned long _waitRate {250};
    unsigned long _waitTimer {0};
protected:
    const unsigned long _minBlinkRate{100};
    const unsigned long _maxBlinkRate{2000};

    bool* _blinkMaskPtr{nullptr};
    uint8_t* _dspAuxBuffPtr{nullptr};
    bool _dspBuffChng{false};
    uint8_t* _dspBuffPtr{nullptr};
    uint8_t _dspDigitsQty{};
    SevenSegDispHw _dspUndrlHw{};
    SevenSegDisplays* _dspInstance;
    uint16_t _dspInstNbr{0};
    int32_t _dspValMax{};
    int32_t _dspValMin{};
    bool _blinking{false};
    bool _blinkShowOn{false};
    unsigned long _blinkTimer{0};
    unsigned long _blinkOffRate{500};
    unsigned long _blinkOnRate{500};
    unsigned long _blinkRatesGCD{500};  //Holds the value for the minimum timer checking the change ON/OFF of the blinking,
                                        //saving unneeded timer interruptions, and without the need of the std::gcd function
    std::string _charSet{"0123456789AabCcdEeFGHhIiJLlnOoPqrStUuY-_=~* ."}; // for using indexOf() method
    uint8_t _charLeds[45] = {   //Values valid for a Common Anode display. For a Common Cathode display values must be logically bit negated
        0xC0, // 0
        0xF9, // 1
        0xA4, // 2
        0xB0, // 3
        0x99, // 4
        0x92, // 5
        0x82, // 6
        0xF8, // 7
        0x80, // 8
        0x90, // 9
        0x88, // A
        0xA0, // a
        0x83, // b
        0xC6, // C
        0xA7, // c
        0xA1, // d
        0x86, // E
        0x84, // e
        0x8E, // F
        0xC2, // G
        0x89, // H
        0x8B, // h
        0xF9, // I
        0xFB, // i
        0xF1, // J
        0xC7, // L
        0xCF, // l
        0xAB, // n
        0xC0, // O
        0xA3, // o
        0x8C, // P
        0x98, // q
        0xAF, // r
        0x92, // S
        0x87, // t
        0xC1, // U
        0xE3, // u
        0x91, // Y
        0xBF, // Minus -
        0xF7, // Underscore _
        0xB7, // Low =
        0xB6, //~ for Equivalent symbol
        0x9C, // Â°
        0xFF, // Space
        0x7F  //.
    };

    uint8_t _space {0xFF};
    uint8_t _dot {0x7F};
    std::string _zeroPadding{""};
    std::string _spacePadding{""};

    unsigned long blinkTmrGCD(unsigned long blnkOnTm, unsigned long blnkOffTm);
    void restoreDspBuff();
    void saveDspBuff();
    void setAttrbts();
    void updBlinkState();
    void updWaitState();

public:
    /**
     * @brief Default class constructor
     *
     */
    SevenSegDisplays();
    /**
     * @brief Class constructor
     *
     * @param dspUndrlHw Underlying hardware display.
     *
     *  Is the physical device used to display the information generated by this object, and stored in it's buffer attribute.
     *  As such it has physical properties that might condition some of this object characteristics, some has no incidence, including:
     *  - Digits (a.k.a. ports) quantity.
     *  - Type of led connection (common Anode/ common Cathode).
     *  - Quantity and position of semicolons.
     *  - Managed brightness levels.
     *
     */
    SevenSegDisplays(SevenSegDispHw dspUndrlHw);
    ~SevenSegDisplays();
    /**
     * @brief Makes the display blink the contents it is showing.
     *
     * The display blinks until a noBlink() method is invoked. The display will continue blinking even if the contents are changed. By default all the digits blink, but each digit might be configured individually to blink or not by using the setBlinkMask() method. When invoking this method with no parameters the blinking is symmetrical, meaning that the time the display shows the contents and the time the display is blank are equal. The blinking starts at a preset rate the first time the method is invoked. The blinking rate can be changed by using the setBlinkRate() method. After changing the blinking rate, the new blinking rate will be kept after a noBlink() or a new blink() without parameters call is done, until it is modified with a new setBlinkRate(const unsigned long, const unsigned long) call, or it is restarted by a blink(const unsigned long, const unsigned long) with parameters. Note that to restart the blinking with a blink() the service must first be stopped, as the method call makes no changes if the blinking service was already running.
     *
     * @retval true: If the display was not already set to blink (so now the blinking starts).
     * @retval false: The display was already set to blink.
     */
    bool blink();
    /**
     * @brief
     *
     * @param onRate Time (in milliseconds) the display must stay on, the value must be in the range _minBlinkRate <= onRate <= _maxBlinkRate. Those preset values can be known by the use of the getMinBlinkRate() and the getMaxBlinkRate() methods.
     * @param offRate (Optional) Time (in milliseconds) the display must stay off, the value must be in the range _minBlinkRate <= offRate <= _maxBlinkRate. Those preset values might be known by the use of the getMinBlinkRate() and the getMaxBlinkRate() methods. If no offRate value is provided the method will assume it's a symmetric blink call and use a value for offRate equal to the value passed for onRate.
     *
     * @retval true: If the display was not already set to blink (so now the blinking starts).
     * @retval false: The display was already set to blink, and/or one or more of the parameters passed was out of range.
     */
    bool blink(const unsigned long &onRate, const unsigned long &offRate = 0);
    /**
     * @brief Clears the display, turning off all the segments and dots.
     *
     * @note The clearing process involves writing **spaces** to every display port. Due to physical display characteristics this may not be equal to write a '\0' to them.
     *
     */
    void clear();
    /**
     * @brief Displays a basic graphical representation of the level of fulfillment or completeness of two segmented values or tasks.
     *
     *  The display gives a general fast notion on the matter, as a battery charge level, liquids deposit level, time remaining, tasks completeness and so on. The levels are represented by the horizontal segments (0, 1, 2 or 3 from bottom to top), and a character might be added before each of the graphical representations to give an indication of what the display is showing, passed through the **labelLeft** and **labelRight** parameters. As four digit ports must be used, this method only applies to displays with 4 or more digits, the display is splitted in two sectors, the left side and the right side, and each one of them must have a valid value (0 <= value <= 3) to enable them to be displayed, and might have (or not) a single displayable character to give a visual hint to what the value is showing. For more information check the **gauge()** method.
     *
     * @param levelLeft The value to display for the two left side 7 segments display ports, must be in the range 0 <= level <= 3.
     * @param levelRight The value to display for the two right side 7 segments display ports, must be in the range 0 <= level <= 3.
     * @param labelLeft A char, optional parameter (if not specified the default value, a Space, will be assumed), that will be displayed in the leftmost digit of the display. The character must be one of the "displayable" characters, as listed in the **print()** method description.
     * @param labelRight A char, optional parameter (if not specified the default value, a Space, will be assumed), that will be displayed in the position left to the **levelRight** display, just before the levelRight value. The character must be one of the "displayable" characters, as listed in the **print()** method description.
     *
     * @retval If the values could be represented.
     * @retval Otherwise, being that the **levelLeft** and/or **levelRight** parameter was out of range and/or the **labelLeft** and/or **labelRight** parameter was not in the list of displayable characters. The display will be blanked.
     *
     */
    bool doubleGauge(const int &levelLeft, const int &levelRight, char labelLeft = ' ', char labelRight = ' ');
    /**
     * @brief Displays a basic graphical representation of the level of fulfillment or completeness of a segmented value or task.
     *
     * The display gives a general fast notion on the matter, as a battery charge level, liquids deposit level, time remaining, tasks completeness and so on. The levels are represented by the horizontal segments (0, 1, 2 or 3 from bottom to top, and from left to right), and a character might be added before the graphical representation to give an indication of what the display is showing. This method is usable in displays which have from 4 digits and up, as the representation makes use of 4 digits or les.
     *
     * @param level The integer value to display, must be in the range 0 <= level <= 3.
     * @param label (Optional) A character that might be added before (leftmost port) the graphical representation to give an indication of what the display is showing, if not specified the default value, a space, will be assumed. The character must be one of the "displayable" characters, as listed in the print(std::string) method description.
     * @return
     */
    bool gauge(const int &level, char label = ' ');
    bool gauge(const double &level, char label = ' ');
    uint8_t getDigitsQty();
    /**
     * @brief Gets the greatest integer number value displayable by the display.
     *
     * The value is calculated according to the quantity of digits -ports- the display has as indicated at the object instantiation.
     *
     * @return The greatest integer value display capability.
     *
     */
    int32_t getDspValMax();
    /**
     * @brief Gets the minimum integer number value displayable by the display.
     *
     * The value is calculated according to the quantity of digits -ports- the display has as indicated at the object instantiation.
     *
     * @return The greatest integer value display capability.
     *
     * @note The use of the leftmost port to represent the **-** (minus) sign is considered.
     *
     */
    int32_t getDspValMin();
    uint16_t getInstanceNbr();
    unsigned long getMaxBlinkRate();
    unsigned long getMinBlinkRate();
    /**
     * @brief Returns a value indicating if the display is blank
     *
     * @retval true: all the display ports hold a **space** value.
     * @retval false: at least one of the display ports hold a value different to **space** value.
     *
     * @note The condition to be blank is that all the display ports are exhibiting the _space character, not to be confused with '\0'
    */
    bool isBlank();
    bool isBlinking();
    bool isWaiting();
    bool noBlink();
    bool noWait();
    bool print(std::string text);
    bool print(const int32_t &value, bool rgtAlgn = false, bool zeroPad = false);
    bool print(const double &value, const unsigned int &decPlaces, bool rgtAlgn = false, bool zeroPad = false);
    void resetBlinkMask();
    void setBlinkMask(const bool* newBlnkMsk);
    bool setBlinkRate(const unsigned long &newOnRate, const unsigned long &newOffRate = 0);
    bool setWaitChar (const char &newChar);
    bool setWaitRate(const unsigned long &newWaitRate);
    bool wait();
    bool wait(const unsigned long &newWaitRate);
    bool write(const uint8_t &segments, const uint8_t &port);
    bool write(const std::string &character, const uint8_t &port);

};

//============================================================> Class declarations separator

class ClickCounter{
private:
    SevenSegDisplays _display;
    int _count{0};
    int _beginStartVal{0};
    bool _countRgthAlgn{true};
    bool _countZeroPad{false};
public:
    ClickCounter(uint8_t ccSclk, uint8_t ccRclk, uint8_t ccDio, bool rgthAlgn = true, bool zeroPad = false, bool commAnode = true, const uint8_t dspDigits = 4);
    ~ClickCounter();
    bool blink();
    bool blink(const unsigned long &onRate, const unsigned long &offRate = 0);
    void clear();
    bool countBegin(int32_t startVal = 0);  //To be analyzed it's current need
    bool countDown(int32_t qty = 1);
    bool countReset();
    bool countRestart(int32_t restartValue = 0);
    bool countStop();   //To be analyzed it's current need
    bool countToZero(int32_t qty = 1);
    bool countUp(int32_t qty = 1);
    int32_t getCount();
    int32_t getStartVal();
    bool noBlink();
    bool setBlinkRate(const unsigned long &newOnRate, const unsigned long &newOffRate = 0);
    bool updDisplay();  //To be analyzed it's current need
};

//============================================================> Class declarations separator



#endif /* _SEVENSEGDISPLAYS_STM32_H_ */
